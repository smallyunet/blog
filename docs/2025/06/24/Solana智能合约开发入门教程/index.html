<!DOCTYPE html><html lang="zh-cn"><head><title>Solana 智能合约开发教程</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="smallyu的博客" type="application/atom+xml">
</head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
  var navbar = document.querySelector('nav.navbar');
  if (navbar) {
    navbar.classList.remove('navbar-fixed-top');
  }
}
</script><div><div class="inner"><h1>Solana 智能合约开发教程</h1><div class="time">2025-06-24</div><div class="title-margin"></div><p>这个一个零基础的系列教程，可以从最基本的操作开始学会 Solana 智能合约的开发。一共 3 个部分：</p>
<ul>
<li><a href="#%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B-1">第一部分</a>：基础环境安装、HelloWorld 合约部署、链上合约调用</li>
<li><a href="#%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B-2">第二部分</a>：实现 USDT 合约的最小模型，自定义数据结构与方法</li>
<li><a href="#%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B-3">第三部分</a>：使用官方 SPL 库复用合约功能，完成标准化代币的发行</li>
</ul>
<br>

<h2 id="开发教程-1"><a href="#开发教程-1" class="headerlink" title="开发教程-1"></a>开发教程-1</h2><p>我们将从最基础的操作开始，学习 Solana 智能合约的开发。你只需要普通的编程基础，理解面向对象等概念就可以，不需要事先知道其他网络的智能合约概念，也不需要知道 Rust 语言的编程理念。</p>
<h3 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1. 安装环境"></a>1. 安装环境</h3><p>访问 Solana 官方提供的安装教程：<a href="https://solana.com/docs/intro/installation">https://solana.com/docs/intro/installation</a></p>
<p>文档中提供了一键安装全部依赖的单个命令行，也有分阶段安装的详细教程。要注意其中 Solana Cli 是需要修改环境变量文件的。安装好一切后，<code>solana</code> 命令应该是可用的：</p>
<pre><code class="bash">solana --help
</code></pre>
<h3 id="2-初始化项目"><a href="#2-初始化项目" class="headerlink" title="2. 初始化项目"></a>2. 初始化项目</h3><p>使用 anchor 命令来初始化一个智能合约的项目，这个命令行工具在上个步骤已经安装好了，可以先不用管生成的目录结构是什么样子：</p>
<pre><code class="bash">anchor init hello_sol
cd hello_sol
</code></pre>
<h3 id="3-写入合约代码"><a href="#3-写入合约代码" class="headerlink" title="3. 写入合约代码"></a>3. 写入合约代码</h3><p><code>programs/hello_sol/src</code> 目录下有一个 <code>lib.rs</code> 文件，<code>.rs</code> 结尾意味着这是一个 Rust 语言的代码文件。把这些代码复制进去，注意 <code>declare_id</code> 中的内容是你的项目在初始化的时候，就会自动为你生成，不需要原封不动复制下面的内容：</p>
<pre><code class="rust">use anchor_lang::prelude::*;

declare_id!(&quot;3Zbdw1oWu1CiMiQr3moQeT4XzMgeqmCvjH5R5wroDWQH&quot;);

#[program]
pub mod hello_sol &#123;
    use super::*;

    pub fn say_hello(ctx: Context&lt;Hello&gt;) -&gt; Result&lt;()&gt; &#123;
        msg!(&quot;Hello, world!&quot;);
        Ok(())
    &#125;
&#125;

#[derive(Accounts)]
pub struct Hello &#123;&#125;
</code></pre>
<h3 id="4-编译智能合约"><a href="#4-编译智能合约" class="headerlink" title="4. 编译智能合约"></a>4. 编译智能合约</h3><p>使用 anchor 命令编译你刚才复制进去的智能合约代码，确保编译是成功的，代码没有写错。编译过程中可能会有一些警告，那些警告不要紧，因为 Rust 语言对于代码非常严格，很小的问题都会抛出大段的警告。如果一切顺利，命令行的输出不会有错误日志：</p>
<pre><code class="bash">anchor build
</code></pre>
<h3 id="5-设置本地默认网络"><a href="#5-设置本地默认网络" class="headerlink" title="5. 设置本地默认网络"></a>5. 设置本地默认网络</h3><p>运行这个命令，让你本地的 solana 命令默认使用 devnet，因为 devnet 是给开发者使用的，可以用来测试自己的程序，而不需要真的花钱去买 SOL 代币：</p>
<pre><code class="bash">solana config set --url https://api.devnet.solana.com
</code></pre>
<h3 id="6-创建本地账户文件"><a href="#6-创建本地账户文件" class="headerlink" title="6. 创建本地账户文件"></a>6. 创建本地账户文件</h3><p>这个命令用于在你本地的默认路径下，创建一个用来部署智能合约的 Solana 账户。因为部署智能合约需要消耗手续费，这些手续费需要一个账户来支付：</p>
<pre><code class="bash">solana-keygen new -o ~/.config/solana/id.json  
</code></pre>
<p>这个命令的运行结果中，有一行 <code>pubkey: </code> 开头的输出，pubkey 后面的就是你本地的账户地址。因为上一个步骤已经设置了 devnet 为默认网络，所以可以直接使用这个命令来查看你本地账户的余额：</p>
<pre><code class="bash">solana balance
</code></pre>
<p>也可以打开 devnet 的 <a href="https://explorer.solana.com/?cluster=devnet">浏览器</a>，搜索你刚才生成的地址。搜索之后的 URL 形如：
<a href="https://explorer.solana.com/address/75sFifxBt7zw1YrDfCdPjDCGDyKEqLWrBarPCLg6PHwb?cluster=devnet">https://explorer.solana.com/address/75sFifxBt7zw1YrDfCdPjDCGDyKEqLWrBarPCLg6PHwb?cluster=devnet</a></p>
<p>当然，你会发现自己的账户余额是 <code>0 SOL</code>。</p>
<h3 id="7-领取-devnet-上的空投"><a href="#7-领取-devnet-上的空投" class="headerlink" title="7. 领取 devnet 上的空投"></a>7. 领取 devnet 上的空投</h3><p>运行这个命令，你的账户就可以收到 2 个 SOL。其中参数里的 2 就是请求发放 2 个 SOL 的意思。因为领水的额度限制，你只能一次性最多领 2 个。不用担心太少，足够我们接下来的步骤使用了。</p>
<pre><code class="bash">solana airdrop 2
</code></pre>
<h3 id="8-部署合约到-devnet"><a href="#8-部署合约到-devnet" class="headerlink" title="8. 部署合约到 devnet"></a>8. 部署合约到 devnet</h3><p>现在我们已经有了智能合约代码，有了本地账户，并且本地账户里有 SOL 余额。现在可以部署合约到 devnet 上了。运行这个命令：</p>
<pre><code class="bash">anchor deploy --provider.cluster devnet 
</code></pre>
<p>如果部署成功，会看到 <code>Deploy success</code> 的字样。命令行输出中还有一行需要留意，<code>Program Id: </code> 后面的，就是部署之后的合约地址，你可以直接在 devnet 的浏览器上搜索这个地址，然后看到类似这个 URL 的页面，URL 中的 <code>3Zbdw1oWu1CiMiQr3moQeT4XzMgeqmCvjH5R5wroDWQH</code> 就是我部署的合约地址：<a href="https://explorer.solana.com/address/3Zbdw1oWu1CiMiQr3moQeT4XzMgeqmCvjH5R5wroDWQH?cluster=devnet">https://explorer.solana.com/address/3Zbdw1oWu1CiMiQr3moQeT4XzMgeqmCvjH5R5wroDWQH?cluster=devnet</a></p>
<h3 id="9-调用链上合约"><a href="#9-调用链上合约" class="headerlink" title="9. 调用链上合约"></a>9. 调用链上合约</h3><p>到 <code>hello_sol/app</code> 目录下，新建一个叫 <code>app.js</code> 的文件，把这些代码复制进去。简单来说，这段代码读取了你本地默认的账户文件，然后用你的 Solana 账户发起一笔对智能合约调用的交易，这个脚本每执行一次，就会在链上创建一笔交易。：</p>
<pre><code class="javascript">const anchor = require(&#39;@coral-xyz/anchor&#39;);
const fs     = require(&#39;fs&#39;);
const os     = require(&#39;os&#39;);
const path   = require(&#39;path&#39;);
const &#123; Keypair, Connection &#125; = anchor.web3;

const RPC_URL    = process.env.RPC_URL;
const connection = new Connection(RPC_URL, &#123; commitment: &#39;confirmed&#39; &#125;);

const secretKey = Uint8Array.from(
  JSON.parse(
    fs.readFileSync(
      path.join(os.homedir(), &#39;.config/solana/id.json&#39;),
      &#39;utf8&#39;,
    ),
  ),
);

const wallet   = new anchor.Wallet(Keypair.fromSecretKey(secretKey));
const provider = new anchor.AnchorProvider(connection, wallet, &#123;
  preflightCommitment: &#39;confirmed&#39;,
&#125;);
anchor.setProvider(provider);

const idlPath = path.resolve(__dirname, &#39;../target/idl/hello_sol.json&#39;);
const idl     = JSON.parse(fs.readFileSync(idlPath, &#39;utf8&#39;));
const program = new anchor.Program(idl, provider);

(async () =&gt; &#123;
  try &#123;
    const sig = await program.methods.sayHello().rpc();
    console.log(&#39;✅ tx&#39;, sig);
    console.log(`🌐 https://explorer.solana.com/tx/$&#123;sig&#125;?cluster=devnet`);
  &#125; catch (err) &#123;
    console.error(&#39;❌&#39;, err);
  &#125;
&#125;)();
</code></pre>
<p>返回 <code>hello_sol</code> 项目的顶层目录，执行这些命令来安装 nodejs 的依赖：</p>
<pre><code>npm init -y 
npm install @coral-xyz/anchor
</code></pre>
<p>然后记得现在仍然是在顶层目录，运行这个命令，来执行刚才写的 <code>app.js</code> 脚本，脚本会到 devnet 上调用我们部署的智能合约：</p>
<pre><code class="bash">export RPC_URL=https://api.devnet.solana.com
node app/app.js
</code></pre>
<p>这里有一个环境变量 <code>RPC_URL</code> 是脚本请求的 API 地址，因为 nodejs 脚本默认不走系统代理，所以对于网络受阻的同学，需要用一个比公开 RPC 更好用的 API 地址。可以使用例如 <a href="https://www.helius.dev/">Helius</a> 的服务，注册一个免费的账号就可以了。假如执行脚本的过程中遇到下面的错误，那就说明是网络问题，换一个好用的 RPC 地址就好了：</p>
<pre><code class="javascript">❌ Error: failed to get recent blockhash: TypeError: fetch failed
    at Connection.getLatestBlockhash (/Users/smallyu/work/github/hello_sol/node_modules/@solana/web3.js/lib/index.cjs.js:7236:13)
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
    at async AnchorProvider.sendAndConfirm (/Users/smallyu/work/github/hello_sol/node_modules/@coral-xyz/anchor/dist/cjs/provider.js:89:35)
    at async MethodsBuilder.rpc [as _rpcFn] (/Users/smallyu/work/github/hello_sol/node_modules/@coral-xyz/anchor/dist/cjs/program/namespace/rpc.js:15:24)
    at async /Users/smallyu/work/github/hello_sol/app/app.js:40:17
</code></pre>
<p>你也许好奇为什么不需要指定调用的合约地址，这个脚本怎么知道你刚才，部署到链上的合约在哪里？注意看脚本中有一个 <code>idlPath</code> 的变量，你可以直接打开这个路径的文件 <code>target/idl/hello_sol.json</code> 查看，里面是一些合约编译后的元信息，包括合约的地址也在里面，没错合约地址是离线生成的，不需要上链，合约就有属于自己的唯一地址了。</p>
<p>如果执行脚本没有输出错误，就会看到终端打印出了这一次调用合约的交易哈希，以及可以直接复制访问的浏览器 URL，例如这就是一笔调用合约的交易：
<a href="https://explorer.solana.com/tx/2fnPgKkv3tGKKq72hhRxmW6WFSXuofMzXfY2UYoFZXTdJi37btdESy9NzS2gjpWzXX4CL5F7QfxugpctBVaMcBFY?cluster=devnet">https://explorer.solana.com/tx/2fnPgKkv3tGKKq72hhRxmW6WFSXuofMzXfY2UYoFZXTdJi37btdESy9NzS2gjpWzXX4CL5F7QfxugpctBVaMcBFY?cluster=devnet</a></p>
<p>这笔交易页面的最下方，可以看到我们写的智能合约在被交易调用后，打印出了 <code>Program logged: &quot;Hello, world!&quot;</code> 的日志，这正是我们写在合约代码中的 msg。</p>
<h3 id="10-Troubleshooting"><a href="#10-Troubleshooting" class="headerlink" title="10. Troubleshooting"></a>10. Troubleshooting</h3><p>如果在执行上述命令或者代码的过程中，遇到了错误，可以优先考虑是命令行工具版本的问题。由于区块链行业和技术迭代比较快，很容易出现版本不兼容的情况。我本地的环境和版本是：</p>
<pre><code class="text">rustup: rustup 1.28.2 (e4f3ad6f8 2025-04-28)
rustc: rustc 1.90.0-nightly (706f244db 2025-06-23)
solana: solana-cli 2.2.18 (src:8392f753; feat:3073396398, client:Agave)
archor: anchor-cli 0.31.1
node: v24.2.0
@coral-xyz/anchor(nodejs): ^0.31.1
</code></pre>
<p><br><br></p>
<h2 id="开发教程-2"><a href="#开发教程-2" class="headerlink" title="开发教程-2"></a>开发教程-2</h2><p>我们已经学会了如何创建智能合约项目、部署合约以及调用连上合约，接下来深入了解一下智能合约编程语言的写法，关注如何写出自己想要的逻辑。我们将会以写一个简单的 USDT 代币合约为例，分析相关的代码，并且理解 Solana 智能合约的写法。</p>
<h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><p>用我们已经学会的命令，来创建一个新的项目：</p>
<pre><code class="bash">anchor init usdt_clone
</code></pre>
<h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><p>可以注意到项目路径 <code>programs/usdt_clone/Cargo.toml</code> 下的这个文件，Cargo 是 Rust 语言常用的包管理器，这个 <code>Cargo.toml</code> 则是包管理器的配置文件，指定了要引入哪些依赖库，以及依赖库的版本。我们自动生成的配置文件里有这么两行：</p>
<pre><code class="Rsut">[dependencies]
anchor-lang = &quot;0.31.1&quot;
</code></pre>
<p>Anchor 提供的宏是 Solana 智能合约的关键，宏的形式如 <code>#[program]</code>、<code>#[account]</code> 等，这些宏会告诉 Solana 的 SVM 虚拟机，程序从哪里开始、数据结构在哪里定义等。如果没有 Anchor 这个依赖，合约项目就是普通的 Rust 语言项目了，Solana 的智能合约系统无法识别和解析。这也就解释了，Solana 的智能合约，是如何利用 Rust 语言来实现的。</p>
<h3 id="3-合约地址"><a href="#3-合约地址" class="headerlink" title="3. 合约地址"></a>3. 合约地址</h3><p>我们近距离看一下合约的代码文件 <code>usdt_clone/programs/usdt_clone/src/lib.rs</code>。文件的第一行内容是这样，<code>use</code> 把 Anchor 常用的类型一下子全部导入进来了，这没什么问题，不需要修改，方便我们后续编写程序。：</p>
<pre><code class="Rsut">use anchor_lang::prelude::*;
</code></pre>
<p>第二行内容是一个对 <code>declare_id</code> 函数的调用，<code>declare_id</code> 声明了当前这个智能合约项目的 Program ID，也就是合约地址是什么，之前我们提到过，Solana 的智能合约地址，是可以离线生成的。</p>
<pre><code class="Rsut">declare_id!(&quot;CFmGdHuqDymqJYBX44fyNjrFoJx6wRkZPkYgZqfkAQvT&quot;);
</code></pre>
<p>这个合约地址是一个随机值，但不是随意格式的值，它是一个 Ed25529 的公钥。假如你手动把最后一个字符 <code>T</code> 改为 <code>t</code>，这整个字符串就不是一个合法的公钥了，所以这个值可以随机生成，但是不能随便改。那么既然是公钥，它的私钥在哪里呢？在初始化项目的时候，会自动生成一个私钥，文件位置在 <code>target/deploy/usdt_clone-keypair.json</code>，可以打开看到是一些字节数组，<code>declare_id</code> 使用的公钥，就是根据这个私钥生成的。</p>
<h3 id="4-储存数据结构"><a href="#4-储存数据结构" class="headerlink" title="4. 储存数据结构"></a>4. 储存数据结构</h3><p>接下来我们需要新增一些自己的逻辑，在 <code>declare_id</code> 语句的下方，写入这个代码：</p>
<pre><code class="Rsut">#[account]
pub struct Mint &#123;
    pub decimals: u8,
    pub mint_authority: Pubkey,
&#125;
</code></pre>
<p>可以理解为 <code>#[account]</code> 宏是用来定义数据结构的，Anchor 黑魔法会在背后进行一系列操作，让我们可以针对这个数据结构在链上进行读写操作。这里的代码很简单，我们定义了一个叫 <code>Mint</code> 的结构体，这个结构体包含两个属性，<code>decimals</code> 指定 USDT 代币的精度是多少，<code>mint_authority</code> 指定谁可以来挖新的币。</p>
<p>我们继续定义另一个结构体，用来储存每一个用户的代币数量。<code>owner</code> 就是用户地址，<code>balance</code> 则是用户的余额：</p>
<pre><code class="Rsut">#[account]
pub struct TokenAccount &#123;
    pub owner: Pubkey,
    pub balance: u64,
&#125;
</code></pre>
<h3 id="5-账户约束结构"><a href="#5-账户约束结构" class="headerlink" title="5. 账户约束结构"></a>5. 账户约束结构</h3><p>你可能注意到当前的代码文件最底部，还有两行自动生成的 <code>#[derive(Accounts)]</code> 开头的代码。这个宏是用来给账户写一些约束规则的。我们可以在 <code>#[derive(Accounts)]</code> 内部定义一些函数，然后再用 <code>#[account]</code> 来定义结构体，那么这个结构体就自动拥有了所有函数。类似于给结构体定义成员函数的意思。</p>
<p>把原本的 <code>Initialize</code> 代码删掉：</p>
<pre><code class="Rsut">#[derive(Accounts)]
pub struct Initialize &#123;&#125;    // 删除
</code></pre>
<p>然后写入我们自己的逻辑：</p>
<pre><code class="Rust">#[derive(Accounts)]
pub struct InitMint&lt;&#39;info&gt; &#123;
    #[account(
        init, 
        payer = authority,
        space = 8 + 1 + 32
    )]
    pub mint: Account&lt;&#39;info, Mint&gt;,

    #[account(mut)]
    pub authority: Signer&lt;&#39;info&gt;,

    pub system_program: Program&lt;&#39;info, System&gt;,
&#125;
</code></pre>
<p>这段代码有点复杂。我们先看 <code>#[account(...)]</code> 这一段，这里给 <code>account()</code> 函数传递了 3 个参数进去，<code>account()</code> 函数的参数类型是 Anchor 框架定义的，第一个参数 <code>init</code> 是一个固定的关键字，不需要值，表示如果账户不存在，则创建一个新的账户。第二个参数 <code>payer</code> 是需要值的，表示谁来支付创建账户的手续费。第三个参数 <code>space</code> 的值则是我们自己计算的，系统必须预留 8 + <code>Mint</code> 结构体的第一个字段类型 <code>u8</code> 需要空间 1 + <code>Mint</code> 结构体的第二个字段类型 <code>Pubkey</code> 需要空间 32。</p>
<p>这个 <code>#[account(...)]</code> 的宏用来修饰 <code>mint</code> 成员变量。我们接着看 <code>mint</code> 这个成员变量，<code>Account</code> 是 Anchor 框架提供的内置的账户类型，可以对储存数据结构进行读写，例如我们之前定义的 <code>Mint</code> 或者 <code>TokenAccount</code> 结构，这个 <code>mint</code> 成员变量实际操作这些类型的数据。而 <code>Account</code> 接受两个泛型参数，第二个参数 <code>Mint</code> 指明了这个账户是在处理 <code>Mint</code> 类型的结构，而不是 <code>TokenAccount</code> 或者其他。</p>
<p>接着看 <code>#[account(mut)]</code> 这个宏，mut 的意思是账户金额可以变化。<code>authority</code> 也是一个成员变量，它的类型同样是一个 Anchor 内置的账户类型 <code>Signer</code>，与 <code>Account</code> 不同的是，<code>Signer</code> 意味着需要传入账户持有者本人签名，才符合类型定义。后面的 <code>‘info</code> 则是一个泛型参数，其中 <code>info</code> 是结构体的泛型传递进来的。至于 <code>info</code> 前面的单引号 <code>&#39;</code>，是 Rust 语言里的一个特性，可以简单理解为对参数的引用传递。整体来看，这两行代码的宏和语句，共同定义了一个可以对其扣费的账户地址作为成员变量。</p>
<p>最后的 <code>system_program</code> 成员变量，可以把这一行理解为固定写法，只要合约需要转账 SOL，就得写上这一行。总的来说，这几行代码定义了一个新的结构体 <code>InitMint</code>，这个结构体是基于 <code>Mint</code> 进行包装的，包装后的 <code>InitMint</code> 拥有了一些账户相关的属性。</p>
<h3 id="6-代币合约初始化"><a href="#6-代币合约初始化" class="headerlink" title="6. 代币合约初始化"></a>6. 代币合约初始化</h3><p>接下来开始关注 <code>#[program]</code> 宏定义的函数。这个宏用来标注智能合约的程序入口，也就是真正执行合约逻辑的部分。我们当前文件里有几行默认的代码：</p>
<pre><code class="Rust">#[program]
pub mod usdt_clone &#123;
    use super::*;

    pub fn initialize(ctx: Context&lt;Initialize&gt;) -&gt; Result&lt;()&gt; &#123;   // 删除
        msg!(&quot;Greetings from: &#123;:?&#125;&quot;, ctx.program_id);             // 删除
        Ok(())                                                    // 删除
    &#125;                                                             // 删除
&#125;
</code></pre>
<p>删掉这个项目自动生成的 <code>initialize</code> 函数，我们自己写一个函数：</p>
<pre><code class="Rust">pub fn init_mint(ctx: Context&lt;InitMint&gt;, decimals: u8) -&gt; Result&lt;()&gt; &#123;
    let mint = &amp;mut ctx.accounts.mint;
    mint.decimals = decimals;
    mint.mint_authority = ctx.accounts.authority.key();
    Ok(())
&#125;
</code></pre>
<p>把这个 <code>init_mint</code> 函数放在原先 <code>initialize</code> 函数的位置。如果抛开 Anchor 的宏，这个函数则是一个普通的 Rust 语法定义的函数。<code>Context</code> 类型是 Anchor 提供的包装类型 所以你也许好奇我们明明没有定义 <code>Context</code>，但是这里却直接使用了。<code>InitMint</code> 类型是则我们上一个步骤定义好的。</p>
<p>这个函数接受两个参数，第一个参数的类型是 <code>InitMint</code>，表示哪个账户拥有铸币权限。第二个参数类型是 <code>u8</code>，表示 USDT 的精度是多少位。这个函数返回一个空的元组 <code>()</code>，说明如果成功什么都不返回，如果失败则会报错。</p>
<p>函数内部的逻辑相对好理解，函数把参数接收进来的数据，赋值给了一个叫 <code>mint</code> 的变量，要注意这不是普通的新定义的变量，而是从 <code>ctx.accounts</code> 反序列化过来的、<code>mut</code> 声明的可变类型的变量，相当于直接修改一个引用类型的结构体内的属性值，所以只要给 <code>mint</code> 赋值，结构体内的数据都会保存下来，也就是保存到链上。</p>
<h3 id="7-单元测试"><a href="#7-单元测试" class="headerlink" title="7. 单元测试"></a>7. 单元测试</h3><p>可以先到目录下，运行一下编译，看程序是否写对了，如果编译报错，可能是哪里复制漏了。由于 Rust 语言的编译器非常严格，所以即使没有错误，也会有很多 warning，暂时不用管那些警告信息：</p>
<pre><code class="bash">anchor build  
</code></pre>
<p>接下来到 <code>usdt_clone/tests/usdt_clone.ts</code> 文件，复制这些代码进去：</p>
<pre><code class="ts">import anchor from &quot;@coral-xyz/anchor&quot;;
import &#123; Program &#125; from &quot;@coral-xyz/anchor&quot;;
import &#123; SystemProgram, Keypair &#125; from &quot;@solana/web3.js&quot;;
import &#123; assert &#125; from &quot;chai&quot;;

const &#123; AnchorProvider, BN &#125; = anchor;

describe(&quot;usdt_clone / init_mint&quot;, () =&gt; &#123;
  const provider = AnchorProvider.env();
  anchor.setProvider(provider);
  const program = anchor.workspace.UsdtClone as Program;

  const mintKey = Keypair.generate();

  it(&quot;creates a Mint with correct metadata&quot;, async () =&gt; &#123;
    const txSig = await program.methods
      .initMint(new BN(6))
      .accounts(&#123;
        mint: mintKey.publicKey,
        authority: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      &#125;)
      .signers([mintKey])
      .rpc();

    console.log(&quot;tx:&quot;, txSig);

    const mintAccount = await program.account.mint.fetch(mintKey.publicKey);

    assert.equal(mintAccount.decimals, 6);
    assert.equal(
      mintAccount.mintAuthority.toBase58(),
      provider.wallet.publicKey.toBase58()
    );
  &#125;);
&#125;);
</code></pre>
<p>这段代码使用本地的单元测试框架，构造了一些参数去调用我们在合约里写的 <code>initMint</code> 方法，比如指定精度为 6 位，传递了 <code>InitMint</code> 结构体需要的 3 个参数等。模拟交易的执行结果赋值给了 <code>txSig</code> 变量，可以在输出日志中看到交易哈希。并且在交易结束后，用语句 <code>program.account.mint.fetch</code> 查询了合约的 <code>mint</code> 属性的值，它的精度应该等于我们的参数，authority 也应该是我们本地发起模拟交易的账户地址。</p>
<p>运行这个命令来查看单元测试的效果：</p>
<pre><code class="bash">anchor test
</code></pre>
<p>如果一切顺利，会看到 <code>1 passing (460ms)</code> 的字样。</p>
<h3 id="8-开户和转账"><a href="#8-开户和转账" class="headerlink" title="8. 开户和转账"></a>8. 开户和转账</h3><p>基于上面我们已经看懂的语法规则，可以继续在合约代码中新增这样两个账户结构的定义，分别用来开户和转账。这里的 <code>#[error_code]</code> 是新出现的宏，比较容易理解，它是一个枚举类型，用于程序报错的时候调用：</p>
<pre><code class="rust">#[derive(Accounts)]
pub struct InitTokenAccount&lt;&#39;info&gt; &#123;
    #[account(init, payer = owner, space = 8 + 32 + 8)]
    pub token: Account&lt;&#39;info, TokenAccount&gt;,
    #[account(mut, signer)]
    pub owner: Signer&lt;&#39;info&gt;,
    pub system_program: Program&lt;&#39;info, System&gt;,
&#125;

#[derive(Accounts)]
pub struct Transfer&lt;&#39;info&gt; &#123;
    #[account(mut, has_one = owner)]
    pub from: Account&lt;&#39;info, TokenAccount&gt;,
    #[account(mut)]
    pub to: Account&lt;&#39;info, TokenAccount&gt;,
    #[account(signer)]
    pub owner: Signer&lt;&#39;info&gt;,
&#125;

#[error_code]
pub enum ErrorCode &#123;
    InsufficientFunds,
    ArithmeticOverflow,
&#125;
</code></pre>
<p>然后新增两个方法，分别执行开户的逻辑以及转账的逻辑。注意这里开户的时候，<code>token.balance = 1000</code> 意味着每一个开户的地址，默认都会有 1000 的余额。这里主要是为了简化流程和代码、方便单元测试，这个数字可以随意改动：</p>
<pre><code class="Rust">pub fn init_token_account(ctx: Context&lt;InitTokenAccount&gt;) -&gt; Result&lt;()&gt; &#123;
  let token = &amp;mut ctx.accounts.token;
  token.owner = ctx.accounts.owner.key();
  token.balance = 1000;
  Ok(())
&#125;

pub fn transfer(ctx: Context&lt;Transfer&gt;, amount: u64) -&gt; Result&lt;()&gt; &#123;
  let from = &amp;mut ctx.accounts.from;
  let to   = &amp;mut ctx.accounts.to;

  require!(from.balance &gt;= amount, ErrorCode::InsufficientFunds);

  from.balance -= amount;
  to.balance = to
      .balance
      .checked_add(amount)
      .ok_or(ErrorCode::ArithmeticOverflow)?;

  Ok(())
&#125;
</code></pre>
<p>这是针对开户和转账功能的单元测试代码：</p>
<pre><code class="ts">const tokenA = Keypair.generate();
const tokenB = Keypair.generate();

it(&quot;initializes tokenA &amp; tokenB, each with balance 1000&quot;, async () =&gt; &#123;
  for (const tok of [tokenA, tokenB]) &#123;
    await program.methods
      .initTokenAccount()
      .accounts(&#123;
        token: tok.publicKey,
        owner: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      &#125;)
      .signers([tok])
      .rpc();

    const acc = await program.account.tokenAccount.fetch(tok.publicKey);
    assert.equal(
      acc.owner.toBase58(),
      provider.wallet.publicKey.toBase58()
    );
    assert.equal(acc.balance.toNumber(), 1000);
  &#125;
&#125;);

it(&quot;transfers 250 from A to B (balances 750 / 1250)&quot;, async () =&gt; &#123;
  await program.methods
    .transfer(new BN(250))
    .accounts(&#123;
      from:  tokenA.publicKey,
      to:    tokenB.publicKey,
      owner: provider.wallet.publicKey,
    &#125;)
    .rpc();

  const a = await program.account.tokenAccount.fetch(tokenA.publicKey);
  const b = await program.account.tokenAccount.fetch(tokenB.publicKey);

  assert.equal(a.balance.toNumber(), 750);
  assert.equal(b.balance.toNumber(), 1250);
&#125;);
</code></pre>
<p>如果有兴趣，可以试着把这个合约也部署到 devnet 上，然后通过 SDK 来发起对链上合约的调用。</p>
<p><br><br></p>
<h2 id="开发教程-3"><a href="#开发教程-3" class="headerlink" title="开发教程-3"></a>开发教程-3</h2><p>你也许注意到，在编写智能合约的过程中，对于程序逻辑的描述反而是轻量的，比较复杂的部分是不同类型的 <code>#[account]</code> 宏，以及去了解宏接受的参数，比如是否允许自动创建账户、如果创建应该租用多少个字节的空间等，因为 Solana 的全部账户数据需要加载到节点服务器的内存中，价格比较昂贵，所以要求开发者对于空间的占用计算比较精细。而 Solana 的账户体系又有点复杂，需要稍微理解一下。</p>
<h3 id="1-命令行工具发行代币"><a href="#1-命令行工具发行代币" class="headerlink" title="1. 命令行工具发行代币"></a>1. 命令行工具发行代币</h3><p>对于发行 USDT 这种经典场景，Solana 已经封装好了智能合约的库函数，可以直接调用，甚至封装好了命令行工具，只需要简单的操作，不需要写合约，就可以发行代币。Solana 把这些代币统称为 SPL Token。创建一个 6 位精度的 SPL Token 的命令是这样，注意不需要写代币名字：</p>
<pre><code class="bash">spl-token create-token --decimals 6
</code></pre>
<p>命令行运行结束后，会输出一个 <code>Address</code>，这个就是 SPL Token 的代币地址，比如我得到的地址是 <code>E75GMXAfJ91XuRboSpjwkDmta45Etgt3F3Gf5WLZvLbV</code>，可以在 <a href="https://explorer.solana.com/address/E75GMXAfJ91XuRboSpjwkDmta45Etgt3F3Gf5WLZvLbV?cluster=devnet">区块链浏览器</a> 上查到。</p>
<p>接下来需要一个操作，来给你本地的账户，在这个 USDT 代币上创建一个关联账户（Associated Token Account，ATA）。这个创建关联账户的动作，相当于在合约上实例化一个数据结构，这个数据结构里保存了你的 USDT 余额等信息，如果没有这个数据，USDT 代币的合约上就找不到你。</p>
<p>用 “账户” 这个词可能有点迷惑，我本地已经有账户了，还能用 <code>solana address</code> 命令看到账户地址，为什么还需要专门调用 USDT 的合约，创建什么 ATA 账户？可以理解为，合约里本来有个空的 map{}，创建 ATA 账户就是向 map 里插入了一条数据，key 是你本地的账户地址，value 是 USDT 的余额信息。如果 map 里没有你的信息，你甚至不能接受 USDT 的转账。</p>
<p>那么为什么 Solana 要这么设计，必须先在 map 里开辟空间，才能接受转账呢？因为一开始有提到过，对于 Solana 来说，链上空间是比较珍贵的，map 里开辟一个键值对的空间，也就是创建 ATA 账户，需要占用 165 个字节的内存，这 165 字节不是免费使用的，可以使用命令 <code>solana rent 165</code> 来计算字节数对应的费用，比如这里就会输出 <code>0.00203928 SOL</code>，也就是你创建 ATA 账户的交易，在手续费之外，会多支付这么些租金。所以必须要有创建 ATA 账户这个操作，主要是为了收费。</p>
<p>回到我们的操作，创建 ATA 账户的命令是：</p>
<pre><code class="bash">spl-token create-account E75GMXAfJ91XuRboSpjwkDmta45Etgt3F3Gf5WLZvLbV
</code></pre>
<p>这个命令会显示 <code>Creating account</code>，后面是你的 ATA 地址，比如我的是 <code>E5XmcEJhhGUri8itThLGk8QfPzY1acFid8JmVyo5DWUo</code>,同样的，可以在 <a href="https://explorer.solana.com/address/E5XmcEJhhGUri8itThLGk8QfPzY1acFid8JmVyo5DWUo?cluster=devnet">区块链浏览器</a> 中看得到。</p>
<p>对要注意，ATA 账户是有单独的地址的，比如你本地的账户地址是 <code>a</code>，在 USDT 代币上创建的 ADA 账户地址将是 <code>b</code>，是不一样的。而后续接受 USDT、发送 USDT，将全部通过 ATA 账户来进行，而不是你本地的那个账户。SPL Token 提供了命令来查看本地钱包账户和 ATA 账户的关系：</p>
<pre><code class="bash">spl-token address --verbose --token E75GMXAfJ91XuRboSpjwkDmta45Etgt3F3Gf5WLZvLbV

// 输出是这个样子
Wallet address: 75sFifxBt7zw1YrDfCdPjDCGDyKEqLWrBarPCLg6PHwb
Associated token address: E5XmcEJhhGUri8itThLGk8QfPzY1acFid8JmVyo5DWUo
</code></pre>
<p>那么现在，可以用这个命令，来查询 USDT 的余额，<code>balance</code> 后面的参数是指代币地址，而不是 ATA 地址：</p>
<pre><code class="bash">spl-token balance E75GMXAfJ91XuRboSpjwkDmta45Etgt3F3Gf5WLZvLbV 
</code></pre>
<p>当然默认是 0，现在给这个地址挖一些 USDT 上去。这个命令有点长，有 3 个参数，第一个参数是代币地址，第二个参数是代币数量，第三个参数是 ATA 地址，意味着要挖哪个代币、挖多少、挖给谁：</p>
<pre><code class="bash">spl-token mint E75GMXAfJ91XuRboSpjwkDmta45Etgt3F3Gf5WLZvLbV 5 E5XmcEJhhGUri8itThLGk8QfPzY1acFid8JmVyo5DWUo
</code></pre>
<p>命令执行成功后，就可以查询到余额，也能直接在浏览器上看到余额了，类似的，转账 USDT 的命令是：</p>
<pre><code class="bash">spl-token transfer &lt;MINT&gt; 1 &lt;ATA&gt;
</code></pre>
<p>Solana 为了避免用户不记得自己的 ATA 账户地址，也提供了人性化的命令，最后一个参数可以直接用本地的钱包地址，而不需要 ATA 地址，这也就是为什么我们平时使用 Solana 的钱包，并没有感觉到 ATA 账户这种东西存在的原因：</p>
<pre><code class="bash">spl-token transfer &lt;MINT&gt; 1 &lt;RECIPIENT_WALLET&gt;
</code></pre>
<h3 id="2-用-spl-标准库写智能合约"><a href="#2-用-spl-标准库写智能合约" class="headerlink" title="2. 用 spl 标准库写智能合约"></a>2. 用 spl 标准库写智能合约</h3><p>我们尝试一下在智能合约里调用 spl 库函数，这种官方提供的、系统级别的库函数是经过严格安全审计的，比我们自己写要安全，所以有了这些库函数，我们可以更加关注自己定制化的业务逻辑，不需要关心太底层的东西，比如 USDT 余额计算是否精度有损失之类的问题。先创建一个新项目：</p>
<pre><code class="bash">anchor init usdt_spl
</code></pre>
<p>导入 <code>anchor-spl</code> 依赖，这个命令可以把最新版本的库函数导入进来，命令运行后，可以在 <code>programs/usdt_spl/Cargo.toml</code> 文件的 <code>[dependencies]</code> 部分，新增了这样一行 <code>anchor-spl = &quot;0.31.1&quot;</code>，说明是成功的：</p>
<pre><code class="bash">cargo add anchor-spl
</code></pre>
<p>开始写合约代码程序。先在最开始两行导入 spl 的依赖。我们之前有使用过 Anchor 框架自带的账户类型如 <code>Account</code> 和 <code>Signer</code>，那么这里 spl 也是提供了多种数据类型，比如 <code>TokenAccount</code> 就表示 ATA 账户的数据结构：</p>
<pre><code class="rust">use anchor_spl::token::&#123;self, MintTo, Token, TokenAccount, Mint&#125;;
</code></pre>
<p>接着定义 mint 行为相关的账户规则：</p>
<pre><code class="rust">#[derive(Accounts)]
pub struct MintToCtx&lt;&#39;info&gt; &#123;
    #[account(mut)]
    pub mint: Account&lt;&#39;info, Mint&gt;, 

    #[account(mut)]
    pub to:   Account&lt;&#39;info, TokenAccount&gt;,

    #[account(mut)]
    pub authority: Signer&lt;&#39;info&gt;,

    pub token_program: Program&lt;&#39;info, Token&gt;,
&#125;
</code></pre>
<p>这几行代码中，<code>mut</code> 关键词我们之前用到过，表明账户数据要允许被写入。<code>Account</code> 类型是 anchor 框架自带的，我们也使用过。<code>Mint</code> 类型则是新出现的，是从 spl 框架里导入的，我们之前不是自己定义过一个用 <code>#[Account]</code> 宏标注的 <code>Mint</code> 结构体，然后在 <code>#[derive(Accounts)]</code> 里使用吗。现在有了 spl 库，我们不需要自己定义 <code>Mint</code> 结构体的类型、参数个数，直接使用就好。</p>
<p>同样的，<code>TokenAccount</code> 和 <code>Token</code> 也都是 spl 框架提供的类型。这么看似乎使用 spl 框架比自己写简单了不少？不能高兴的太早，还有一段代码没有写上：</p>
<pre><code class="rust">impl&lt;&#39;info&gt; From&lt;&amp;MintToCtx&lt;&#39;info&gt;&gt; for CpiContext&lt;&#39;_, &#39;_, &#39;_, &#39;info, MintTo&lt;&#39;info&gt;&gt;
&#123;
    fn from(accts: &amp;MintToCtx&lt;&#39;info&gt;) -&gt; Self &#123;
        let cpi_accounts = MintTo &#123;
            mint:      accts.mint.to_account_info(),
            to:        accts.to.to_account_info(),
            authority: accts.authority.to_account_info(),
        &#125;;
        CpiContext::new(accts.token_program.to_account_info(), cpi_accounts)
    &#125;
&#125;
</code></pre>
<p>这段代码乍一看眼花缭乱，可能要晕了，为什么那么多尖括号，为什么那么多单引号和下划线。这就是 Rust，为了迎合独特的内存管理设计，不得不让语言在语法形式上变得复杂。</p>
<p><code>impl ... From&lt;...&gt; for ...</code> 是 Rust 的语法规则，大意是让一种类型变为另一种类型，我们这里就是让 <code>From&lt;&amp;MintToCtx&lt;&#39;info&gt;&gt;</code> 类型变为 <code>CpiContext&lt;&#39;_, &#39;_, &#39;_, &#39;info, MintTo&lt;&#39;info&gt;&gt;</code>。其中 <code>MintToCtx</code> 是我们上面自己用 <code>#[derive(Accounts)]</code> 宏定义的类型，然后作为泛型参数传递给了 <code>From</code>，而这个 <code>From</code>，是 Rust 标准库提供的一个包装类型，用来接受我们传入的参数。</p>
<p>至于后面的 <code>CpiContext</code> 部分，Cpi 的全称是跨程序调用 Cross-Program Invocation，用于把要调用的外部程序，以及账户类型，都打包到一个统一的数据结构中。前三个参数不用管，最后的 <code>MintTo</code> 是我们真正传入的类型，这个类型是 spl 库提供的。</p>
<p>那么也许这里有疑问，为什么还涉及到调用外部程序？CpiContext 又是如何知道要调用哪个外部程序的？这个和 Solana 智能合约的设计有关，SPL Token 不止是一些类型定义，而且是实际已经部署在 Solana 网络上的程序。我们在使用 spl 依赖库的过程，实际上就是去调用那些已经预先在 Solana 网络上部署的 spl 合约。智能合约在运行的时候，发现你要调用 spl，就去找 spl 的合约地址，执行一些操作，然后返回结果。相当于整个网络上的智能合约都在复用同一套 spl 合约。</p>
<p>所以要留意 Solana 智能合约依赖库的实现方式，和其他网络是有不同的。Solana 在设计上让程序和数据分离，以致于可以实现程序共享的模式。为什么我们不自己部署一套 spl 合约，或者每个人都各自部署一套 spl 合约，然后自己使用呢？一方面是需要付出额外的手续费成本，另一方面是 Solana 的智能合约本来就允许程序共享，你要是自己部署一套，用户都不知道你有没有偷偷修改标准库的代码，反而不安全了。</p>
<p>还有最后一部分 <code>#[program]</code> 里的程序逻辑要补齐：</p>
<pre><code class="rust">pub fn mint_to(ctx: Context&lt;MintToCtx&gt;, amount: u64) -&gt; Result&lt;()&gt; &#123;
    token::mint_to((&amp;*ctx.accounts).into(), amount)
&#125;
</code></pre>
<h3 id="3-编译合约"><a href="#3-编译合约" class="headerlink" title="3. 编译合约"></a>3. 编译合约</h3><p>现在代码没问题，但是如果现在编译合约项目，会遇到报错。需要修改下 <code>programs/usdt_spl/Cargo.toml</code> 文件，把这两行的特性打开：</p>
<pre><code class="rust">[features]
idl-build = [&quot;anchor-lang/idl-build&quot;, &quot;anchor-spl/idl-build&quot;]

[dependencies]
anchor-spl  = &#123; version = &quot;0.31.1&quot;, features = [&quot;token&quot;, &quot;idl-build&quot;] &#125;
</code></pre>
<p>因为静态编译的时候，命令行默认没有把 spl 标准库给带上，在配置文件里指明就可以了。现在项目可以编译成功：</p>
<pre><code class="bash">anchor build
</code></pre>
<h3 id="4-写单元测试"><a href="#4-写单元测试" class="headerlink" title="4. 写单元测试"></a>4. 写单元测试</h3><p>安装 spl 相关的 nodejs 依赖，注意单元测试用的是 ts 语言，不是 Rust 语言：</p>
<pre><code class="bash">npm i @coral-xyz/anchor@^0.31 @solana/spl-token chai
</code></pre>
<p>把单元测试代码复制到 <code>tests/usdt_spl.ts</code> 文件中：</p>
<pre><code class="ts">import anchor from &quot;@coral-xyz/anchor&quot;;
import &#123; Program &#125; from &quot;@coral-xyz/anchor&quot;;
import &#123;
  createMint,
  createAssociatedTokenAccount,
  getAccount,
  TOKEN_PROGRAM_ID,
&#125; from &quot;@solana/spl-token&quot;;
import &#123; assert &#125; from &quot;chai&quot;;

const &#123; AnchorProvider, BN &#125; = anchor;

describe(&quot;usdt_spl / mint_to&quot;, () =&gt; &#123;
  const provider = AnchorProvider.env();
  anchor.setProvider(provider);
  const program = anchor.workspace.UsdtSpl as Program;

  let mintPubkey: anchor.web3.PublicKey;
  let ata: anchor.web3.PublicKey;

  it(&quot;creates mint, mints 1 USDT into ATA&quot;, async () =&gt; &#123;
    mintPubkey = await createMint(
      provider.connection,
      provider.wallet.payer,          // fee-payer
      provider.wallet.publicKey,      // mint authority
      null,                           // freeze authority
      6                               // decimals
    );

    ata = await createAssociatedTokenAccount(
      provider.connection,
      provider.wallet.payer,          // fee-payer
      mintPubkey,
      provider.wallet.publicKey       // owner
    );

    await program.methods
      .mintTo(new BN(1_000_000))      // 1 USDT
      .accounts(&#123;
        mint: mintPubkey,
        to: ata,
        authority: provider.wallet.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      &#125;)
      .rpc();

    const accInfo = await getAccount(provider.connection, ata);
    assert.equal(accInfo.amount.toString(), &quot;1000000&quot;);
  &#125;);
&#125;);
</code></pre>
<p>运行单元测试，会看到成功的输出：</p>
<pre><code class="bash">anchor test
</code></pre>
<h3 id="5-部署合约到-devnet"><a href="#5-部署合约到-devnet" class="headerlink" title="5. 部署合约到 devnet"></a>5. 部署合约到 devnet</h3><p>确保账户里余额足够，然后用 anchor 来部署合约：</p>
<pre><code class="bash">anchor deploy --provider.cluster devnet 
</code></pre>
<p>这个命令偶尔会因为网络问题执行失败，抛出 <code>Operation timed out</code> 错误。可以直接把 provider 的参数改为自己的 rpc 地址，如果网址比较长，可以用双引号括一下：</p>
<pre><code class="bash">anchor deploy --provider.cluster &quot;&lt;your-rpc-url&gt;&quot;
</code></pre>
<p>因为网络问题带来的麻烦有可能还不止如此，比如本地存在写入了一部分但是为完成的 buffer、链上存在 buffer 但是本地不存在导致状态不一致等问题，为了直接跳过那些问题，可以直接这种这样的命令：</p>
<pre><code class="bash">solana program deploy \
  target/deploy/usdt_spl.so \
  --program-id target/deploy/usdt_spl-keypair.json \
  --url &quot;&lt;your-rpc-url&gt;&quot;
</code></pre>
<p>这个命令更加好用。如果没有带 <code>--program-id</code> 参数，这个命令会自动新生成 keypair，也就意味着会把合约部署的新的地址，这个根据自己的需求来选择。部署成功后，就可以去 <a href="https://explorer.solana.com/address/CFXzAhGKEz7tSFdNcVeCX8HosFGYczD7rZyD4vwoWozY?cluster=devnet">区块链浏览器</a> 上查看了。</p>
<h3 id="6-使用-SDK-调用链上合约"><a href="#6-使用-SDK-调用链上合约" class="headerlink" title="6. 使用 SDK 调用链上合约"></a>6. 使用 SDK 调用链上合约</h3><p>我们之前使用过 SDK，现在再来使用和复习一下，编辑 <code>app/app.js</code> 文件，把代码复制进去：</p>
<pre><code class="ts">// scripts/mint_to.js   (CommonJS)
const anchor = require(&quot;@coral-xyz/anchor&quot;);
const &#123;
  createMint,
  createAssociatedTokenAccount,
  getAccount,
  TOKEN_PROGRAM_ID,
&#125; = require(&quot;@solana/spl-token&quot;);
const fs   = require(&quot;fs&quot;);
const os   = require(&quot;os&quot;);
const path = require(&quot;path&quot;);
const &#123; Keypair, Connection, PublicKey &#125; = anchor.web3;

const RPC_URL = process.env.RPC_URL || &quot;https://api.devnet.solana.com&quot;;
const connection = new Connection(RPC_URL, &#123; commitment: &quot;confirmed&quot; &#125;);

const secret = Uint8Array.from(
  JSON.parse(fs.readFileSync(path.join(os.homedir(), &quot;.config/solana/id.json&quot;)))
);
const wallet = new anchor.Wallet(Keypair.fromSecretKey(secret));
const provider = new anchor.AnchorProvider(connection, wallet, &#123;
  preflightCommitment: &#39;confirmed&#39;,
&#125;);
anchor.setProvider(provider);

const idl  = JSON.parse(fs.readFileSync(path.resolve(&quot;target/idl/usdt_spl.json&quot;)));
const prog = new anchor.Program(idl, provider);

(async () =&gt; &#123;
  const mint = await createMint(connection, wallet.payer, wallet.publicKey, null, 6);
  const ata  = await createAssociatedTokenAccount(connection, wallet.payer, mint, wallet.publicKey);

  const sig = await prog.methods
    .mintTo(new anchor.BN(1_000_000))
    .accounts(&#123; mint, to: ata, authority: wallet.publicKey, tokenProgram: TOKEN_PROGRAM_ID &#125;)
    .rpc();

  console.log(&quot;tx:&quot;, sig);
  console.log(`explorer: https://explorer.solana.com/tx/$&#123;sig&#125;?cluster=devnet`);

  const bal = await getAccount(connection, ata);
  console.log(&quot;balance:&quot;, bal.amount.toString());
&#125;)();
</code></pre>
<p>如果一切顺利，可以看到这样的运行结果：</p>
<pre><code>~/work/github/sol_contract/usdt_spl main ❯ node app/app.js
tx: 3MgHxsfnJp68mrrABvCh9iwNm6MSXp1SEvk7vDYHoW7KhTEHfVNyMWsbfbEAXTC9gLzcmWu5xbkzia8hgZrcZ18i
explorer: https://explorer.solana.com/tx/3MgHxsfnJp68mrrABvCh9iwNm6MSXp1SEvk7vDYHoW7KhTEHfVNyMWsbfbEAXTC9gLzcmWu5xbkzia8hgZrcZ18i?cluster=devnet
balance: 1000000
</code></pre>
</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5JRBZ6P1W3"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-5JRBZ6P1W3');</script></html>