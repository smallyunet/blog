<!-- Stable asset version (for cache busting without full-site churn)--><!DOCTYPE html><html lang="zh-cn"><head><title>JAVA中的几种设计模式</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><!-- Mobile viewport: include viewport-fit=cover to allow CSS safe-area usage on full-screen devices--><meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"><!-- iOS Safari / PWA status bar style (use default so text stays legible on light background)--><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"><!-- SEO basics--><meta name="description"><!-- Open Graph & Twitter--><link rel="canonical" href="https://smallyu.net/2017/02/11/JAVA中的几种设计模式/"><meta property="og:title" content="JAVA中的几种设计模式"><meta property="og:type" content="article"><meta property="og:url" content="https://smallyu.net/2017/02/11/JAVA中的几种设计模式/"><meta property="og:site_name" content="smallyu的博客"><meta name="twitter:card" content="summary_large_image"><!-- Browser UI color--><meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0f1115"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><!-- stylesheets--><!-- Use a stable, configurable asset version to prevent full-site churn on every build.--><!-- Set `asset_version` in theme _config.yml when you actually change CSS/JS.--><link rel="stylesheet" href="/css/xcode.min.css?v=v1"><link rel="stylesheet" href="/css/post.css?v=v1"><!-- unified typography overrides for both home and post pages--><link rel="stylesheet" href="/css/typography.css?v=v1"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="smallyu的博客" type="application/atom+xml">
</head><body><div><div class="inner"><h1>JAVA中的几种设计模式</h1><div class="time">2017-02-11</div><div class="title-margin"></div><p><strong>单例模式</strong></p>
<p>饿汉模式</p>
<blockquote>
<p>Singleton.java</p>
</blockquote>
<pre><code class="java">package com.imooc;
public class Singleton &#123;
    // 1.将构造方法私有化，不允许外部直接创建对象
    private Singleton() &#123;
        
    &#125;
    // 2.创建类的唯一示例,使用private static修饰
    private static Singleton instance = new Singleton();
    // 3.提供一个用于获取示例的方法
    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<p>饿汉模式指第二步时，加载类的同时生成了实例化的对象。特点是加载类时比较慢，但运行时获取对象的速度比较快，线程安全。</p>
<blockquote>
<p>Test.java</p>
</blockquote>
<pre><code class="java">package com.imooc;
public class Test &#123;
    private static void main(String\[\] args) &#123;
        Singleton s1 = Singleton.getInstance;
        Singleton s2 = Singleton.getInstance;
    &#125;
&#125;
</code></pre>
<p>懒汉模式</p>
<blockquote>
<p>Singleton2.java</p>
</blockquote>
<pre><code class="java">package com.imooc

public class Singleton2 &#123;
    // 1.将构造方法私有化，不允许外部直接创建对象
    private Singleton2() &#123;
        
    &#125;

    // 2.创建类的唯一示例,使用private static修饰
    private static Singleton2 instance;

    // 3.提供一个用于获取示例的方法
    public static Singleton2 getInstance() &#123;
        if(install==null)&#123;
            instance = new Singleton2();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<p>懒汉模式指第二步没有实例化对象，而是在第三步，当调用方法，才会判断并进行实例化，特点是加载类时比较快，但运行时获取对象的速度比较慢，线程不安全。</p>
<p><strong>模板方法模式</strong>  </p>
<p>应用场景为模拟制备饮料。制备饮料一共有四个步骤，即为RefreshBeverage.java中注释中写到的四步。泡制饮料和加入调味料在抽象基类中没有提供具体的实现方法，只是定义接口方法，在子类中应用模板方法模式分别实现具体内容。</p>
<p>第四步加入调味料用到了钩子方法，可以提高代码灵活性，判断子类要泡制的饮料中要不要加入调味料。</p>
<blockquote>
<p>RefreshBeverage.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.template;

/**
 * 抽象基类，为所有子类提供一个算法框架
 * 
 * 提神饮料
 */
public abstract class RefreshBeverage &#123;
    
    /**
     * 制备饮料的模板方法
     * 封装了所有子类共同遵循的算法框架
     */
    public final void prepareBeverageTemplate() &#123;
        // 步骤1 将水煮沸
        boilWater();
        // 步骤2 泡制饮料
        brew();
        // 步骤3 将饮料倒入杯中
        pourInCup();
        if(isCustomerWantsCondiments())&#123;
            // 步骤4 加入调味料
            addCondiments();
        &#125;
    &#125;

    /**
     * Hook，钩子函数，提供一个默认或空的实现
     * 具体的子类可以自行决定是否挂钩或者如何挂钩
     * 询问用户是否加入调料
     */
    protected boolean isCustomerWantsCondiments() &#123;
        return true;
    &#125;

    /**
     * 基本方法，将水煮沸
     */
    private void boilWater() &#123;
        System.out.println(&quot;将水煮沸&quot;);
    &#125;

    /**
     * 抽象的基本方法，泡制饮料
     */
    protected abstract void brew();

    /**
     * 基本方法，将饮料倒入杯中
     */
    private void pourInCup() &#123;
        System.out.println(&quot;将饮料倒入杯中&quot;);
    &#125;

    /**
     * 抽象的基本方法，加入调味料
     */
    protected abstract void addCondiments();
&#125;
</code></pre>
<blockquote>
<p>Coffee.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.template;

/**
 * 具体子类，提供了咖啡制备的具体实现
 */
public class Coffee extends RefreshBeverage &#123;
    
    protected void brew() &#123;
        System.out.println(&quot;用沸水冲泡咖啡&quot;);
    &#125;

    protected void addCondiments() &#123;
        System.out.println(&quot;加入糖和牛奶&quot;);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>Tea.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.template;

/**
 * 具体子类，提供了制备茶的具体实现
 */
public class Tea extends RefreshBeverage &#123;

    protected void brew() &#123;
        System.out.println(&quot;用80度的热水浸泡茶叶5分钟&quot;);
    &#125;

    protected void addCondiments() &#123;
        System.out.println(&quot;加入柠檬&quot;);
    &#125;
    
    /**
     * 子类通过覆盖的方式选择挂载钩子函数
     */
    protected boolean isCustomerWantsCondiments()&#123;
        return false;
    &#125;

&#125;
</code></pre>
<blockquote>
<p>RefreshBeverageTest.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.template;

public class RefreshBeverageTest &#123;

    public static void main(String\[\] args) &#123;

        System.out.println(&quot;制备咖啡...&quot;);
        RefreshBeverage b1 = new Coffee();
        b1.prepareBeverageTemplate();
        System.out.println(&quot;咖啡好了！&quot;);
        
        System.out.println(&quot;****************************************&quot;);
        
        System.out.println(&quot;制备茶...&quot;);
        RefreshBeverage b2 = new Tea();
        b2.prepareBeverageTemplate();
        System.out.println(&quot;茶好了！&quot;);
    &#125;

&#125;
</code></pre>
<p>运行结果：  </p>
<pre><code>制备咖啡...    
将水煮沸   
用沸水冲泡咖啡        
将饮料倒入杯中    
加入糖和牛奶    
咖啡好了！    
\**********************************   
制备茶...   
将水煮沸    
用80度的热水浸泡茶叶5分钟   
将饮料倒入杯中    
茶好了！    
</code></pre>
<p>其中用到的钩子方法会使子类更加灵活。</p>
<p><strong>适配器模式</strong></p>
<p>应用场景为模拟二相转三相插座适配器，NoteBook需要三相电流供电，但只有二相电流插座，TwoPlugAdapter.java中适配了二相电流。</p>
<blockquote>
<p>ThreePlugIf.java</p>
</blockquote>
<pre><code class="java">package com.imooc.apttern.adapter;
/**
 * 三相插座接口
 */
public interface ThreePlugIf &#123;
  // 使用三相电流供电
  public void powerWithThree()&#123;
        
  &#125;
&#125;
</code></pre>
<blockquote>
<p>GBTwoPlug.java</p>
</blockquote>
<pre><code class="java">package com.imooc.apttern.adapter;

public class GBTwoPlug &#123;
  // 使用二相电流供电
  public void powerWithTwo()&#123;
    System.out.println(&quot;使用二相电流供电&quot;);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>NoteBook.java</p>
</blockquote>
<pre><code class="java">package com.imooc.apttern.adapter;

public class NoteBook &#123;
  private ThreePlugIf plug;
  public NoteBook(ThreePlugIf plug)&#123;
    this.plug = plug;
  &#125;
  // 使用插座充电
  public void change()&#123;
    plug.powerWithThree();
  &#125;
  public static void main(String[] args)&#123;
    GBTwoPlug two = new GBTwoPlug();
    ThreePlugIf three = new TwoPlugAdapter(two);
    NoteBook nb = new NoteBook(three);
    nb.change();
  &#125;
&#125;
</code></pre>
<blockquote>
<p>TwoPlugAdapter.java</p>
</blockquote>
<pre><code class="java">package com.imooc.apttern.adapter;

/**
 * 二相转三相的插座适配器
 */
public class TwoPlugAdapter implements ThreePlugIf &#123;
  private GBTwoPlug plug;
  public TwoPlugAdapter(GBTwoPlug plug)&#123;
    this.plug = plug;
  &#125;
  public void powerWithThree() &#123;
    System.out.println(&quot;通过转化&quot;);
    plug.powerWithTwo();
  &#125;
&#125;
</code></pre>
<p>运行结果：  </p>
<pre><code>通过转化
使用二相电流供电
</code></pre>
<p><strong>策略模式</strong></p>
<p>策略模式将可变部分从程序中抽象分离成算法接口，在该接口下分别封装一系列算法实现</p>
<p>What is composition ?</p>
<p>在类中增加一个私有域，引用另一个已有的类的实例，通过调用引用实例的方法从而获得新的功能，这种设计被称作组合（复合）。</p>
<p>策略模式的优点：</p>
<blockquote>
<p>1.使用了组合，是架构更加灵活</p>
<p>2.富有弹性，可以较好的应对变化（开——闭原则）</p>
<p>3.更好的代码复用性（相对于继承）</p>
<p>4.消除大量的条件语句</p>
</blockquote>
<p>策略模式的缺点：</p>
<blockquote>
<p>1.客户代码需要了解每个策略的细节</p>
<p>2.增加了对象的数目</p>
</blockquote>
<p>策略模式的应用场景：</p>
<blockquote>
<p>1.许多相关的类仅仅是行为差异</p>
<p>2.运行时选取不同的算法变体</p>
<p>3.通过条件语句在多个分支中选取一</p>
</blockquote>
<p>代码的应用场景模拟了鸭子的生产过程，鸭子一共有三个行为：展示、鸣叫、飞行。不同的鸭子有不同的飞行行为，使用到了策略模式。  </p>
<blockquote>
<p>Duck.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.strategy;

/**
 * 超类，所有的鸭子都要继承此类
 * 抽象了鸭子的行为：显示和鸣叫
 */
public abstract class Duck &#123;
  /**
   * 鸭子发出叫声
   * 通用行为，由超类实现
   */
  public void quack()&#123;
    System.out.println(&quot;嘎嘎嘎&quot;);
  &#125;
  /**
   * 显示鸭子的外观
   * 鸭子的外观不相同，声明为abstract，由子类实现
   */
  public abstract void display();
  private FlyingStrategy flyingStrategy;
  public void setFlyingStrategy(FlyingStrategy flyingStrategy)&#123;
    this.flyingStrategy = flyingStrategy;
  &#125;
  public void fly()&#123;
    flyingStrategy.performFly();
  &#125;
&#125;
</code></pre>
<blockquote>
<p>FlyingStrategy.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.strategy;

/**
 * 策略接口，实现鸭子的飞行行为
 */
public interface FlyingStrategy &#123;
  void performFly();
&#125;
</code></pre>
<blockquote>
<p>MallardDuck.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.strategy;

import com.imooc.pattern.strategy.impl.FlyWithWin;

// 绿脖鸭
public class MallardDuck extends Duck &#123;
  public MallardDuck()&#123;
    super();
    super.setFlyingStrategy(new FlyWithWin());
  &#125;
  @Override
  public void display() &#123;
    System.out.println(&quot;我的脖子是绿色的&quot;);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>RedheadDuck.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.strategy;

import com.imooc.pattern.strategy.impl.FlyWithWin;

// 红头鸭
public class RedheadDuck extends Duck &#123;
  public RedheadDuck()&#123;
    super();
    super.setFlyingStrategy(new FlyWithWin());
  &#125;
  public void display() &#123;
    System.out.println(&quot;我的头是红色的&quot;);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>RubberDuck.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.strategy;

import com.imooc.pattern.strategy.impl.FlyNoWay;

// 橡胶鸭
public class RubberDuck extends Duck &#123;
  public RubberDuck()&#123;
    super();
    super.setFlyingStrategy(new FlyNoWay());
  &#125;
  @Override
  public void display() &#123;
    System.out.println(&quot;我全身发黄，嘴巴很红&quot;);
  &#125;
  public void quack()&#123;
    // 叫声稍有不同，复写了父类方法
    System.out.println(&quot;嘎~嘎~嘎~&quot;);
  &#125;
&#125;
</code></pre>
<p>不同的飞行策略类：</p>
<blockquote>
<p>FlyWithWin.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.strategy.impl;

import com.imooc.pattern.strategy.FlyingStrategy;

public class FlyWithWin implements FlyingStrategy &#123;
  @Override
  public void performFly() &#123;
    System.out.println(&quot;振翅高飞&quot;);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>FlyNoWay.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.strategy.impl;

import com.imooc.pattern.strategy.FlyingStrategy;

public class FlyNoWay implements FlyingStrategy &#123;
  @Override
  public void performFly() &#123;
    System.out.println(&quot;我不会飞行！&quot;);
  &#125;
&#125;
</code></pre>
<p>最后测试生产出的鸭子：  </p>
<blockquote>
<p>DuckTest.java</p>
</blockquote>
<pre><code class="java">package com.imooc.pattern.strategy;

public class DuckTest &#123;
  public static void main(String[] args)&#123;
    System.out.println(&quot;测试鸭子程序&quot;);
    Duck duck = null;
//      duck = new MallardDuck();
//      duck = new RedheadDuck();
    duck = new RubberDuck();
    duck.display();
    duck.quack();
    duck.fly();
    System.out.println(&quot;测试完毕&quot;);
  &#125;
&#125;
</code></pre>
<p>运行结果:</p>
<pre><code>测试鸭子程序    
我全身发黄，嘴巴很红    
嘎~嘎~嘎~   
我不会飞行！    
测试完毕    
</code></pre>
<p>这样就用JAVA实现了策略模式。</p>
<p><strong>代理模式</strong></p>
<blockquote>
<p>远程代理：为不同地理的对象提供局域网代表对象</p>
<p>虚拟代理：根据需要将资源消耗很大的对象进行延迟，真正需要的时候进行创建</p>
<p>保护代理：控制用户的访问权限</p>
<p>智能引用代理：提供对目标对象额外服务</p>
</blockquote>
<p>应用场景模拟了汽车行驶时间的显示和日志记录两个功能。  </p>
<blockquote>
<p>Moveable.java</p>
</blockquote>
<pre><code class="java">package com.imooc.proxy;

// 接口文件
public interface Moveable &#123;
  void move();
&#125;
</code></pre>
<blockquote>
<p>Car.java</p>
</blockquote>
<pre><code class="java">package com.imooc.proxy;

import java.util.Random;

public class Car implements Moveable &#123;
  public void move() &#123;
    // 实现开车
    try&#123;
      Thread.sleep(new Random().nextInt(1000));
      System.out.println(&quot;汽车行驶中……&quot;);
    &#125;catch(InterruptedException e)&#123;
      e.printStackTrace();
    &#125;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>Car2.java  </p>
</blockquote>
<pre><code class="java">package com.imooc.proxy;

// 实现汽车行驶时间
public class Car2 extends Car &#123;
  public void move()&#123;
    long strattime = System.currentTimeMillis();
    System.out.println(&quot;汽车开始行驶……&quot;);
    super.move();
    long endtime = System.currentTimeMillis();
    System.out.println(&quot;汽车结束行驶中…… 汽车行驶时间：&quot;+(endtime-strattime)+&quot;毫秒！&quot;);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>Car3.java</p>
</blockquote>
<pre><code class="java">package com.imooc.proxy;

// 时间代理实现汽车行驶时间
public class Car3 implements Moveable &#123;
  public Car3(Car car) &#123;
    super();
    this.car = car;
  &#125;
  private Car car;
  public void move()&#123;
    long strattime = System.currentTimeMillis();
    System.out.println(&quot;汽车开始行驶……&quot;);
    car.move();
    long endtime = System.currentTimeMillis();
    System.out.println(&quot;汽车结束行驶中…… 汽车行驶时间：&quot;+(endtime-strattime)+&quot;毫秒！&quot;);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>Car4.java</p>
</blockquote>
<pre><code class="java">package com.imooc.proxy;

// 增加log记录代理
public class Car4 implements Moveable &#123;
  public Car4(Moveable m) &#123;
    super();
    this.m = m;
  &#125;
  private Moveable m;
  public void move()&#123;
    System.out.println(&quot;日志开始……&quot;);
    m.move();
    System.out.println(&quot;日志结束……&quot;);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>Client.java</p>
</blockquote>
<pre><code class="java">package com.imooc.proxy;

/**
 * 测试类
 */
public class Client &#123;
    public static void main(String[] args)&#123;
  // 直接
//      Car car = new Car();
//      car.move();
  // 使用集成方法
//      Moveable m = new Car2();
//      m.move();
  // 使用聚合方法
//      Car car = new Car();
//      Moveable m = new Car3(car);
//      m.move();
  // 增加日志记录
  Car car = new Car();
  Car3 ctp = new Car3(car);
  Car4 clp = new Car4(ctp);
  clp.move();
    &#125;
&#125;
</code></pre>
<p>运行结果像这样：  </p>
<pre><code>日志开始……    
汽车开始行驶……    
汽车行驶中……    
汽车结束行驶中…… 汽车行驶时间：497毫秒！    
日志结束……    
</code></pre>
<p>下面使用动态代理来是代码更灵活（<strong>有错误</strong>）。</p>
<blockquote>
<p>TimeHandler.java</p>
</blockquote>
<pre><code class="java">package com.imooc.jdkproxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

import com.imooc.proxy.Car;

/**
 * JDK动态代理
 * 只能代理实现了接口的类
 * 没有实现接口的类不能实现JDK的动态代理
 */
public class TimeHandler implements InvocationHandler &#123;
  public TimeHandler(Object target)&#123;
    super();
    this.target = target;
  &#125;
  private Object target;
  /**
   * 参数
   * proxy 被代理对象
   * method 被代理的方法
   * args 方法的参数
   * 返回值
   * Object 方法的返回值
   */
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
    long strattime = System.currentTimeMillis();
    System.out.println(&quot;汽车开始行驶……&quot;);
    method.invoke(target, args);
    long endtime = System.currentTimeMillis();
    System.out.println(&quot;汽车结束行驶中…… 汽车行驶时间：&quot;+(endtime-strattime)+&quot;毫秒！&quot;);
    return null;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>Test.java</p>
</blockquote>
<pre><code class="java">package com.imooc.jdkproxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

import com.imooc.proxy.Car;
import com.imooc.proxy.Moveable;

/**
 * JDK动态代理测试类
 */
public class Test &#123;
  public static void main(String[] args)&#123;
    Car car = new Car();
    InvocationHandler h = new TimeHandler(car);
    Class&lt;?&gt; cls = car.getClass();
    /**
     * loader 类加载器
     * interface 实现接口
     * h InvocationHandler
     */
    Moveable m = (Moveable)Proxy.newProxyInstance(cls.getClassLoader(), cls.getInterfaces(), h);
    m.move();
  &#125;
&#125;
</code></pre>
<p>etc.</p>
</div></div></body><!-- Defer non-critical scripts for better performance--><script defer src="/js/jquery.min.js?v=v1"></script><script defer src="/js/highlight.min.js?v=v1"></script><script defer src="/js/main.js?v=v1"></script><script defer src="/js/lightbox.js?v=v1"></script><script defer src="/js/bootstrap.min.js?v=v1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5JRBZ6P1W3"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-5JRBZ6P1W3');</script></html>