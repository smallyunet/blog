<!-- Stable asset version (for cache busting without full-site churn)--><!DOCTYPE html><html lang="zh-cn"><head><title>PHP中多种常用的设计模式举例</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><!-- Mobile viewport: include viewport-fit=cover to allow CSS safe-area usage on full-screen devices--><meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"><!-- iOS Safari / PWA status bar style (use default so text stays legible on light background)--><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"><!-- SEO basics--><meta name="description"><!-- Open Graph & Twitter--><link rel="canonical" href="https://smallyu.net/2017/01/25/PHP中多种常用的设计模式举例/"><meta property="og:title" content="PHP中多种常用的设计模式举例"><meta property="og:type" content="article"><meta property="og:url" content="https://smallyu.net/2017/01/25/PHP中多种常用的设计模式举例/"><meta property="og:site_name" content="smallyu的博客"><meta name="twitter:card" content="summary_large_image"><!-- Browser UI color--><meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0f1115"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><!-- stylesheets--><!-- Use a stable, configurable asset version to prevent full-site churn on every build.--><!-- Set `asset_version` in theme _config.yml when you actually change CSS/JS.--><link rel="stylesheet" href="/css/xcode.min.css?v=v1"><link rel="stylesheet" href="/css/post.css?v=v1"><!-- unified typography overrides for both home and post pages--><link rel="stylesheet" href="/css/typography.css?v=v1"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="smallyu的博客" type="application/atom+xml">
</head><body><div><div class="inner"><h1>PHP中多种常用的设计模式举例</h1><div class="time">2017-01-25</div><div class="title-margin"></div><p><strong>适配器模式</strong>  </p>
<blockquote>
<p>1.适配器模式，可以将截然不同的函数接口封装成统一的API</p>
<p>2.实际应用举例，PHP的数据库操作有mysql,musqli,pdo三种，可以用适配器模式统一成一致。类似的场景还有cache适配器，将memcache，redis，file，apc等不同的缓存函数，统一成一致</p>
</blockquote>
<blockquote>
<p>Database.php</p>
</blockquote>
<pre><code class="php">&lt;?php
interdace IDatabase&#123;
  function connect($host, $user, $passwd, $dbname);
  function query($sql);
  function close();
&#125;
</code></pre>
<p>在Database.php中定义了数据库操作的接口，接下来将MySQL、MySQLi、PDO三种数据库操作适配为接口中定义的方法。</p>
<blockquote>
<p>MySQL.php</p>
</blockquote>
<pre><code class="php">&lt;?php
namespace Database;
class MySQL implements IDatabase&#123;
  protected $conn;
  function connect($host, $user, $passwd, $dbname)&#123;
    $conn = mysql_connect($host, $user, $passwd);
    mysql_select_db($dbname, $conn);
    $this-&gt;conn = $conn;
  &#125;
  function query($sql)&#123;
    $res = mysql_query($sql, $this-&gt;conn);
    return $res;
  &#125;
  function close()&#123;
    mysql_close($this-&gt;conn);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>MySQLi.php</p>
</blockquote>
<pre><code class="php">&lt;?php
namespace Database;
class MySQLi implements IDatabase&#123;
  protected $conn;
  function connect($host, $user, $passwd, $dbname)&#123;
    $conn = mysqli_connect($host, $user, $passwd, $dbname);
    $this-&gt;conn = $conn;
  &#125;
  function query($sql)&#123;
    $res = mysqli_query($this-&gt;conn, $sql);
    return $res;
  &#125;
  function close()&#123;
    mysqli_close($this-&gt;conn);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>PDO.php</p>
</blockquote>
<pre><code class="php">&lt;?php
namespace Database;
class PDO implements IDatabase&#123;
  protected $conn;
  function connect($host, $user, $passwd, $dbname)&#123;
    $conn = new \PDO(&quot;mysql:host=$host;dbname=$dbname&quot;, $user, $passwd);
    $this-&gt;conn = $conn;
  &#125;
  function query($sql)&#123;
    return $this-&gt;conn-&gt;query($sql);
  &#125;
  function close()&#123;
    unset($this-&gt;conn);
  &#125;
&#125;
</code></pre>
<p>然后在应用中可以这样使用：</p>
<blockquote>
<p>index.php  </p>
</blockquote>
<pre><code class="php">&lt;?php
$db = new Database\MySQL();
$db-&gt;connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;test&#39;);
$db-&gt;query(&#39;show database&#39;);
$db-&gt;close();
</code></pre>
<p>或者实例化其他类型的数据库，只需要使用同一种标准。</p>
<p><strong>策略模式</strong></p>
<blockquote>
<p>1.策略模式，将一组特定行为和算法封装成类，以适应某些特定的上下文环境，这种模式就是策略模式</p>
<p>2.实际应用举例，假如一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有广告位展示不同的广告</p>
<p>3.使用策略模式可以实现Ioc，依赖倒置、控制反转</p>
</blockquote>
<blockquote>
<p>UserStrategy.php</p>
</blockquote>
<pre><code class="php">&lt;?php
interface UserStrategy &#123;
  function showAd();
  function showCategory();
&#125;
</code></pre>
<p>UserStrategy.php文件定义了用户策略的接口，面对不同的用户将分别实现相应的内容。</p>
<blockquote>
<p>FemaleUserStrategy.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class FemaleUserStrategy implements UserStrategy &#123;
  function showAd() &#123;
    echo &quot;2017新款女装&quot;;
  &#125;
  function showCategory() &#123;
    echo &quot;女装&quot;;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>MaleUserStrategy.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class MaleUserStrategy implements UserStrategy &#123;
  function showAd() &#123;
    echo &quot;IPhone7&quot;;
  &#125;
  function showCategory() &#123;
    echo &quot;电子产品&quot;;
  &#125;
&#125;
</code></pre>
<p>在index.php中这样做就可以实现从硬编码到实现解耦，即不需要修改Page类的内容，只需要传递不同的参数。</p>
<blockquote>
<p>index.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class Page &#123;
  private $strategy;
  function index() &#123;
    echo &quot;AD:&quot;;
    $this-&gt;strategy-&gt;showAd();
    echo &quot;Category:&quot;;
    $this-&gt;strategy-&gt;showCategory();
  &#125;
  function setStrategy(UserStrategy $strategy) &#123;
    $this-&gt;strategy = $strategy;
  &#125;
&#125;
$page = new Page();
if (isset($_GET[&#39;female&#39;])) &#123;
  $strategy = new FemaleUserStrategy();
&#125; else &#123;
  $strategy = new MaleUserStrategy();
&#125;
$page-&gt;setStrategy($strategy);
$page-&gt;index();
</code></pre>
<p><strong>数据对象映射模式</strong>  </p>
<p>数据对象映射模式，是将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作。</p>
<p>在下面的代码中实现数据对象映射模式，我们将实现一个ORM类，将复杂的SQL语句映射成对象属性的操作。</p>
<blockquote>
<p>User.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class User &#123;
  public $id;
  public $mobile;
  public $regtime;
  public $name;

  protected $db;

  function __construct($id) &#123;
    $this-&gt;id = $id;
    $this-&gt;db = new MySQLi();
    $this-&gt;db-&gt;connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;test1&#39;);
    $res = $this-&gt;db-&gt;query(&quot;select * from user where id=&#123;$this-&gt;id&#125; limit 1&quot;);
    $data = $res-&gt;fetch_assoc();
    $this-&gt;name = $data[&#39;name&#39;];
    $this-&gt;mobile = $data[&#39;mobile&#39;];
    $this-&gt;regtime = $data[&#39;regtime&#39;];
  &#125;

  function __destruct() &#123;
    $this-&gt;db-&gt;query(&quot;update user set name=&#39;&#123;$this-&gt;name&#125;&#39;, mobile=&#39;&#123;$this-&gt;mobile&#125;&#39;, regtime=&#39;&#123;$this-&gt;regtime&#125;&#39; where id=&#123;$this-&gt;id&#125; limit 1&quot;);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>index.php</p>
</blockquote>
<pre><code class="php">&lt;?php
$user = new User(1);
$user-&gt;mobile = &#39;18812345678&#39;;
$user-&gt;name = &#39;test&#39;;
$user-&gt;regtime = date(&#39;Y-m-d H:i:s&#39;);
</code></pre>
<p>下面结合使用数据对象映射模式，工厂模式，注册器模式：</p>
<blockquote>
<p>index.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class Page &#123;
  function index() &#123;
    $user = Factory::getUser(1); // 工厂模式的实现
    $user-&gt;name = &#39;rango&#39;;
    $this-&gt;test();
  &#125;
  function test() &#123;
    $user = Factory::getUser(1); // 工厂模式的实现
    $user-&gt;mobile = &#39;18844448888&#39;;
  &#125;
&#125;
$page = new Page();
</code></pre>
<blockquote>
<p>Factory.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class Factory &#123;
  static function getUser($id) &#123;
    $key = &#39;user_&#39;.$id;
    $user = Register::get($key);
    if (!$user) &#123;
      $user = new User($id);
      Register::set($key, $user);
    &#125;
    return $user;
  &#125;
&#125;
</code></pre>
<p><strong>观察者模式</strong></p>
<blockquote>
<p>1.观察者模式（Observer），当一个对象状态发生改变时，依赖它的对象全部会收到通知，并自动更新</p>
<p>2.场景：一个事件发生后，要执行一连串更新操作，传统的编程方式，就是在事件的代码之后直接加入处理逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件主体的代码</p>
<p>3.观察者模式实现了低耦合，非侵入式的通知与更新机制</p>
</blockquote>
<blockquote>
<p>index.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class Event extends EventGenerator &#123;
  function trigger() &#123;
    echo &quot;Event&lt;br /&gt;&quot;;
    $this-&gt;notify();
  &#125;
&#125;
class Observer1 implements Observer &#123;
  function update($event_info = null) &#123;
    echo &quot;逻辑1&lt;br /&gt;&quot;;
  &#125;
&#125;
class Observer2 implements Observer &#123;
  function update($event_info = null) &#123;
    echo &quot;逻辑2&lt;br /&gt;&quot;;
  &#125;
&#125;
$event = new Event;
$event-&gt;addObserver(new Observer1); // 观察者模式的实现
$event-&gt;addObserver(new Observer2); // 观察者模式的实现
$event-&gt;trigger();
</code></pre>
<blockquote>
<p>EventGenerator.php</p>
</blockquote>
<pre><code class="php">&lt;?php
abstract class EventGenerator &#123;
  private $observers = array();
  function addObserver(Observer $observer) &#123;
    $this-&gt;observers[] = $observer;
  &#125;
  function notify() &#123;
    foreach($this-&gt;observers as $observer) &#123;
      $observer-&gt;update();
    &#125;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>Observer.php</p>
</blockquote>
<pre><code class="php">&lt;?php
interface Observer &#123;
  function update($event_info = null);
&#125;
</code></pre>
<p><strong>原型模式</strong></p>
<blockquote>
<p>1.与工厂模式作用类似，都是用来创建对象</p>
<p>2.与工厂模式的实现不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样就免去了类创建时重复的初始化操作</p>
<p>3.原型模式适用于大对象的创建。创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式内存拷贝即可</p>
</blockquote>
<blockquote>
<p>Canvas.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class Canvas &#123;
  // ... 原型对象的复杂初始化
  function init() &#123;
    // 初始化逻辑
  &#125;
  function rect($x1,$y1,$x2,$y2)&#123;
    // 绘制矩形
  &#125;
  function draw()&#123;
    // 输出
  &#125;
&#125;
</code></pre>
<p>index.php将实例化Canvas类以实现图像绘制，并使用关键字clone实现原型模式：  </p>
<blockquote>
<p>index.php</p>
</blockquote>
<pre><code class="php">&lt;?php
$prototype = new Canvas();
$prototype-&gt;init();
// 原型模式
$canvas1 = clone $prototype;
$canvas2 = clone $prototype;
$canvas1-&gt;rect(1,2,3,4);
$canvas1-&gt;draw();
$canvas2-&gt;rect(5,6,7,8);
$canvas2-&gt;draw();
</code></pre>
<p><strong>装饰器模式</strong></p>
<blockquote>
<p>1.装饰器模式（Decorator），可以动态地添加修改类的功能</p>
<p>2.一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重新实现类的方法</p>
<p>3.使用装饰器模式，仅需要在运行时添加一个装饰器对象即可实现，可以实现最大的灵活性</p>
</blockquote>
<blockquote>
<p>DrawDecorator.php</p>
</blockquote>
<pre><code class="php">&lt;?php
interface DrawDecorator &#123;
  function beforeDraw();
  function afterDraw();
&#125;
</code></pre>
<p>DrawDecorator.php定义了装饰器的接口，将会在装饰器类中用到。</p>
<blockquote>
<p>Canvas.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class Canvas &#123;
  protected $decorators = array();
  function draw() &#123;
    $this-&gt;beforeDraw();
    // ... 绘制主体
    $this-&gt;afterDraw();
  &#125;
  function addDecorator(DrawDecorator $decorator) &#123;
    $this-&gt;decorators[] = $decorator;
  &#125;
  function beforeDraw() &#123;
    foreach($this-&gt;decorators as $decorator) &#123;
      $decorator-&gt;beforeDraw();
    &#125;
  &#125;
  function afterDraw() &#123;
    $decorators = array_reverse($this-&gt;decorators); // 后进先出
    foreach($decorators as $decorator) &#123;
      $decorator-&gt;afterDraw();
    &#125;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>ColorDrawDecorator.php</p>
</blockquote>
<pre><code class="php">&lt;?php
// 颜色装饰器
class ColorDrawDecorator implements DrawDecorator &#123;
  function beforeDraw() &#123;
    // 设置颜色
  &#125;
  function afterDraw() &#123;
    // 恢复状态
  &#125;
&#125;
</code></pre>
<p><strong>迭代器模式</strong></p>
<blockquote>
<p>1.迭代器模式，在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素</p>
<p>2.相比于传统的编程模式，迭代器模式可以隐藏遍历元素所需的操作</p>
</blockquote>
<blockquote>
<p>index.php</p>
</blockquote>
<pre><code class="php">&lt;?php
$users = new AllUser();
foreach($users as $user) &#123;
  var_dump($user);
&#125;
</code></pre>
<p>迭代器的实现：</p>
<blockquote>
<p>AllUser.php</p>
</blockquote>
<pre><code class="php">&lt;?php
// 示例装饰器使用
$canvas1 = new Canvas();
$canvas1-&gt;init();
$canvas1-&gt;addDecorator(new ColorDrawDecorator());
$canvas1-&gt;draw();
</code></pre>
<p>这样来使用：</p>
<blockquote>
<p>index.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class AllUser implements \Iterator &#123;
  protected $ids;
  protected $index = 0;
  function __construct() &#123;
    $db = Factory::getDatabase();
    $result = $db-&gt;query(&#39;select id from user&#39;);
    $this-&gt;ids = $result-&gt;fetch_all(MYSQLI_ASSOC);
  &#125;
  function current() &#123;
    $id = $this-&gt;ids[$this-&gt;index][&#39;id&#39;];
    return Factory::getUser($id);
  &#125;
  function next() &#123; $this-&gt;index++; &#125;
  function valid() &#123; return $this-&gt;index &lt; count($this-&gt;ids); &#125;
  function rewind() &#123; $this-&gt;index = 0; &#125;
  function key() &#123; return $this-&gt;index; &#125;
&#125;
</code></pre>
<p><strong>代理模式</strong></p>
<blockquote>
<p>1.在客户端与实体之间建立一个代理对象（proxy），客户端对实体进行操作全部委派给代理对象，隐藏实体的具体实现细节</p>
<p>2.Proxy还可以与业务代码分离，部署到另外的服务器，业务代码中通过RPC来委派任务</p>
</blockquote>
<blockquote>
<p>index.php</p>
</blockquote>
<pre><code class="php">$proxy = new Proxy();
$proxy-&gt;getUserName($id);
$proxy-&gt;setUserName($id, $proxy);
</code></pre>
<blockquote>
<p>Proxy.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class Proxy implements IUserProxy &#123;
  function getUserName($id) &#123;
    $db = Factory::getDatabase(&#39;slave&#39;);
    $db-&gt;query(&quot;select name from user where id=&#123;$id&#125; limit 1&quot;);
  &#125;
  function setUserName($id, $name) &#123;
    $db = Factory::getDatabase(&#39;master&#39;);
    $db-&gt;query(&quot;update user set name=&#39;&#123;$name&#125;&#39; where id=&#123;$id&#125; limit 1&quot;);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>IUserProxy.php</p>
</blockquote>
<pre><code class="php">&lt;?php
interface IUserProxy &#123;
  function getUserName($id);
  function setUserName($id, $name);
&#125;
</code></pre>
</div></div></body><!-- Defer non-critical scripts for better performance--><script defer src="/js/jquery.min.js?v=v1"></script><script defer src="/js/highlight.min.js?v=v1"></script><script defer src="/js/main.js?v=v1"></script><script defer src="/js/lightbox.js?v=v1"></script><script defer src="/js/bootstrap.min.js?v=v1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5JRBZ6P1W3"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-5JRBZ6P1W3');</script></html>